## Vue响应式系统

数据模型是普通的对象，通过更新数据，视图更新。这样对于开发者而言 只需要关注 数据的变化， 专注于业务逻辑开发，做到UI和数据模型最大程度地解耦。

从数据模型(状态) 生成dom，dom输出到界面的流程叫做 *渲染*。 应用在运行时不断的改变数据， 进行重新渲染。响应式系统赋予了重新渲染的能力，这块react也支持类似的响应式系统。 vue.js 响应式系统 最重要的组成部分是变化侦测。

变化侦测的作用，就是发生数据变化时， 告知（通知）视图进行相应的更新。 


## 变化侦测

对于 javascript的世界里，数据模型通常使用 object类型 和数组类型来表示。 学习以下object类型和数组类型是如何进行变化侦测的。

变化侦测通过两种方式来处理， 一种是 "拉" (拉取来知道数据是不是发生变化)， 一种是 "推" (告知相关的数据发生了变化，并做对应的动作)

其中 angular和react采用了 拉的方式

TODO: angular和react是如何 "拉" 的

**Vue.js的变化侦测属于"推"**。当状态发生变化了， vue立刻就知道了。 知道的信息越多，就能做更细纬度的更新。 当然更细纬度，意味着记录着更多的依赖，需要更大的内存开销， 所以当vue2.0的时候，将纬度降到组件级，而不是dom级。同时2.0引入虚拟dom，组件内部使用虚拟dom进行优化对比，大大降低了依赖数量，降低了依赖追踪需要的内存开销。 

vue.js 因为主动推，可以很好的控制推的信息粒度，从而平衡推的粒度和性能。

## 如何追踪变化侦测?? 

如何检测对象的变化?? 通过 `Object.defineProperty` 和 ES6 proxy， 可以收集到依赖。

```vue
<template>
  <div> {{ name }} </div>
</template>
```

在vue中， 模版里面 引入了 name 数据， 使用了 name， 在读 (getter) 的过程记录下来 使用的组件 (依赖)， 在 name 更新 (setter) 的时候， 通知组件（依赖）更新数据。

```javascript
function defineReactive (obj, k, v) {
  let dep = []
  Object.defineProperty(obj, k, {
    enumerable: true,
    configurable: true,
    get () {
      // 收集依赖
      dep.push(window.target)
      return v
    }, 
    set (newVal) {
      if (newVal == v) {
        return
      }
      for(let i = 0; i < dep.length; i++) {
        dep[i](newVal, v)
      }
      val = newVal
    }
  })
}
```

将代码做一系列整理解耦，将依赖抽离出去 

```javascript
class Dep {
  constructor () {
    this.subs = [] // 依赖存储
  }
  addSub (sub) {
    this.subs.push(sub)
  } 
  // 收集依赖
  depend () {
    if (window.target) {
      this.addSub(window.target)
    }
  }
  notify (newVal, val) {
    for(let i = 0; i < this.subs.length; i++) {
      let sub = this.subs[i]
      sub.update(newVal, val)
    }
  }
  update () {}
  remove (sub) {
    if (this.subs.length) {
      const idx = this.subs.indexOf(sub)
      if (idx > -1) {
        this.subs.splice(idx, 1)
      }
    }
  }
}
function defineReactive (obj, k, v) {
  let dep = new Dep()
  Object.defineProperty(obj, k, {
    enumerable: true,
    configurable: true,
    get () {
      // 收集依赖
      dep.depend()
      return v
    }, 
    set (newVal) {
      if (newVal == v) {
        return
      }
      dep.notify(newVal, val)
      val = newVal
    }
  })
}
```

### 收集依赖，依赖都有谁??

#### 依赖类型

根据我们使用vue.js 哪些地方当数据变化的时候，需要更新

- 组件 ( template, jsx, render)
- watch，当数据有watch的时候要告知watch，执行watch函数操作
- computed 当数据有变化，要告知引用它的computed，执行函数

Vue集中把这些不同的需要和需要通知的，都交给了 Watcher类来处理. Watcher类似代理人的身份.

#### 代理人 Watcher

目前单看书籍有点懵，Watcher需要处理什么， 看完实现后稍微有点明白。 首先 Watcher 是个 代理人，去通知其他的操作。 

因此Watcher需要知道:

1. 谁 (什么数据)
2. 作用域
3. 干啥 (对应依赖的操作)

